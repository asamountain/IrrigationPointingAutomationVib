  // Look for sensor keys (slabwgt, slabvwc, etc.)
  if (nodeData.length === 0) {
    console.log('‚ö†Ô∏è  [NETWORK] Node data array is empty');
    return null;
  }
  
  // üîß FIX: Find first non-empty entry (skip empty objects)
  let firstEntry = null;
  let skipCount = 0;
  for (let i = 0; i < Math.min(20, nodeData.length); i++) {
    const entry = nodeData[i];
    if (entry && Object.keys(entry).length > 0) {
      firstEntry = entry;
      skipCount = i;
      break;
    }
  }
  
  if (!firstEntry) {
    console.log('‚ö†Ô∏è  [NETWORK] All entries are empty objects');
    return null;
  }
  
  if (skipCount > 0) {
    console.log(`   ‚Üí Skipped ${skipCount} empty entries, using entry [${skipCount}]`);
  }
  
  // üîß FIX: Look for sensor keys with dynamic suffixes (slabwgt_1, calslabvwc_1, etc.)
  const allKeys = Object.keys(firstEntry);
  console.log(`   ‚Üí Keys in first valid entry: ${allKeys.join(', ')}`);
  
  const sensorKeys = allKeys.filter(k => {
    const lower = k.toLowerCase();
    return (lower.includes('slabwgt') || 
            lower.includes('slabvwc') || 
            lower.includes('calslabvwc')) && 
           k !== 'timestamp' && k !== 't' && k !== 'time';
  });
  
  console.log(`   ‚Üí Available sensors: ${sensorKeys.join(', ')}`);
  
  // Prefer weight sensors (slabwgt_*)
  let targetSensor = sensorKeys.find(k => k.toLowerCase().includes('wgt'));
  if (!targetSensor) {
    targetSensor = sensorKeys[0]; // Fall back to first available
  }
